using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Text;
using System;

using AutoItInterpreter.PartialAST;
using AutoItExpressionParser;
using AutoItCoreLibrary;

namespace AutoItInterpreter
{
    using static InterpreterConstants;
    using static ExpressionAST;


    public static class Generator
    {
#pragma warning disable RCS1197
        public static string Generate(InterpreterState state, InterpreterOptions options)
        {
            StringBuilder sb = new StringBuilder();
            string nl = Environment.NewLine;

            sb.AppendLine($@"
/*
    Autogenerated       {DateTime.Now:ddd yyyy-MM-dd, HH:mm:ss.ffffff}
    Using the command   {options.RawCommandLine}

{string.Concat(state.Errors.Select(err => $"  {err}{nl}"))}
*/
".Trim());

            if (state.Fatal && !options.GenerateCodeEvenWithErrors)
            {
                state.ReportKnownError("errors.generator.cannot_create", new DefinitionContext(state.RootDocument, 0));

                return sb.ToString();
            }

            const string TYPE_VAR_RPOVIDER = nameof(AutoItVariableDictionary);
            const string TYPE_MAC_RPOVIDER = nameof(AutoItMacroDictionary);
            const string TYPE = nameof(AutoItVariantType);
            const string FUNC_MODULE = nameof(AutoItFunctions);
            const string FUNC_PREFIX = "__userfunc_";
            const string PARAM_PREFIX = "__param_";
            const string DISCARD = "__discard";
            const string MACROS = "__macros";
            const string VARS = "__vars";

            string[] glob = { GLOBAL_FUNC_NAME };
            Serializer ser = new Serializer(new SerializerSettings(MACROS, VARS, TYPE, FUNC_PREFIX, func =>
            {
                func = func.ToLower();

                try
                {
                    return state.ASTFunctions.ContainsKey(func) ? null : FUNC_MODULE + '.' + typeof(AutoItFunctions).GetMethod(func, BindingFlags.Static | BindingFlags.Public | BindingFlags.IgnoreCase).Name;
                }
                catch
                {
                    return nameof(AutoItFunctions.__InvalidFunction__);
                }
            }));
            string tstr(EXPRESSION ex) => ex is null ? "«« error »»" : ser.Serialize(ex);
            bool allman = options.Settings.IndentationStyle == IndentationStyle.AllmanStyle;

            sb.AppendLine($@"
using {nameof(AutoItCoreLibrary)};
using System;

namespace AutoIt
{{
    public static class Program
    {{
        private static readonly {TYPE_MAC_RPOVIDER} {MACROS} = new {TYPE_MAC_RPOVIDER}( null /* TODO */ );
        private static readonly {TYPE_VAR_RPOVIDER} {VARS} = new {TYPE_VAR_RPOVIDER}();
        private static {TYPE} __discard = {TYPE}.Null;
".TrimEnd());

            foreach (string fn in state.ASTFunctions.Keys.Except(glob).OrderByDescending(fn => fn).Concat(glob).Reverse())
            {
                AST_FUNCTION function = state.ASTFunctions[fn];
                var paramters = function.Parameters.Select(par =>
                {
                    bool opt = par is AST_FUNCTION_PARAMETER_OPT;

                    return $"{(par.ByRef ? "ref " : "")}{TYPE}{(opt ? "?" : "")} {PARAM_PREFIX}{par.Name.Name}{(opt ? " = null" : "")}";
                });

                if (fn == GLOBAL_FUNC_NAME)
                {
                    sb.AppendLine($@"
        public static void Main(string[] argv)
        {{
            {TYPE} result = ___globalentrypoint();

            // TODO : do something with the main result ?
        }}

        private static {TYPE} ___globalentrypoint()
        {{
".TrimEnd());

                    foreach (AST_LOCAL_VARIABLE v in function.ExplicitLocalVariables)
                        sb.AppendLine($@"            {VARS}[""{v.Variable.Name}""] = {(v.InitExpression is EXPRESSION e ? tstr(e) : TYPE + ".Default")};");

                    _print(function, 4);

                    sb.AppendLine($@"
            return {TYPE}.Default;
        }}
".TrimEnd());
                }
                else
                {
                    sb.AppendLine($@"
        private static {TYPE} {FUNC_PREFIX}{fn}({string.Join(", ", paramters)})
        {{
            {TYPE} inner()
            {{
".TrimEnd());
                    _print(function, 5);

                    sb.AppendLine($@"
                return {TYPE}.Default;
            }}
            {VARS}.{nameof(AutoItVariableDictionary.InitLocalScope)}();");

                    foreach (AST_FUNCTION_PARAMETER par in function.Parameters)
                        sb.AppendLine($@"            {VARS}[""{par.Name.Name}""] = ({TYPE})({PARAM_PREFIX}{par.Name.Name}{(par is AST_FUNCTION_PARAMETER_OPT o ? $" ?? {tstr(o.InitExpression)}" : "")});");

                    foreach (VARIABLE v in function.Parameters.Select(x => x.Name).Concat(function.ExplicitLocalVariables.Select(x => x.Variable)))
                        sb.AppendLine($@"            {VARS}.{nameof(AutoItVariableDictionary.PushLocalVariable)}(""{v.Name}"");");

                    sb.AppendLine($"            {TYPE} result = inner();");

                    foreach (VARIABLE par in function.Parameters.Where(x => x.ByRef).Select(x => x.Name))
                        sb.AppendLine($@"            {PARAM_PREFIX}{par.Name} = {VARS}[""{par.Name}""];");

                    sb.AppendLine($@"            {VARS}.{nameof(AutoItVariableDictionary.DestroyLocalScope)}();
            return result;
        }}
".TrimEnd());
                }
            }

            sb.AppendLine($@"
        private static {TYPE} __critical(string s) => throw new InvalidProgramException(s ?? """");
    }}
}}");

            void _print(AST_STATEMENT e, int indent)
            {
                void println(string s, int i = -1) => sb.Append(new string(' ', 4 * ((i < 1 ? indent : i) - 1))).AppendLine(s);
                void print(AST_STATEMENT s) => _print(s, indent + 1);
                void printblock(AST_STATEMENT[] xs, string p = "", string s = "")
                {
                    if (allman)
                    {
                        if (p.Length > 0)
                            println(p);

                        println("{");
                    }
                    else
                        println(p.Length > 0 ? $"{p} {{" : "{");

                    foreach (AST_STATEMENT x in xs ?? new AST_STATEMENT[0])
                        print(x);

                    if (allman)
                    {
                        println("}");

                        if (s.Length > 0)
                            println(s);
                    }
                    else
                        println(s.Length > 0 ? $"}} {s}" : "}");
                }

                switch (e)
                {
                    case AST_IF_STATEMENT s:
                        printblock(s.If.Statements, $"if ({tstr(s.If.Condition)})");

                        foreach (AST_CONDITIONAL_BLOCK elif in s.ElseIf ?? new AST_CONDITIONAL_BLOCK[0])
                            printblock(elif.Statements, $"else if ({tstr(elif.Condition)})");

                        if (s.OptionalElse is AST_STATEMENT[] b)
                            printblock(b, "else");

                        return;
                    case AST_WHILE_STATEMENT s:
                        printblock(s.WhileBlock.Statements, $"while ({tstr(s.WhileBlock.Condition)})");

                        return;
                    case AST_SCOPE s:
                        println("{");

                        foreach (AST_STATEMENT ls in s.Statements ?? new AST_STATEMENT[0])
                            print(ls);

                        println("}");

                        return;
                    case AST_BREAK_STATEMENT s when s.Level == 1:
                        println("break;");

                        return;
                    case AST_LABEL s:
                        println(s.Name.Replace("<>", "") + ":;", 1);

                        return;
                    case AST_GOTO_STATEMENT s:
                        println($"goto {s.Label.Name.Replace("<>", "")};");

                        return;
                    case AST_ASSIGNMENT_EXPRESSION_STATEMENT s:
                        println(tstr(EXPRESSION.NewAssignmentExpression(s.Expression)) + ';');

                        return;
                    case AST_EXPRESSION_STATEMENT s:
                        println($"{DISCARD} = {tstr(s.Expression)};");

                        return;
                    case AST_INLINE_CSHARP s:
                        println(s.Code);

                        return;
                    case AST_RETURN_STATEMENT s:
                        println($"return {tstr(s.Expression)};");

                        return;
                    default:
                        println($"// TODO: {e}"); // TODO

                        return;
                }
            }

            return Regex.Replace(sb.ToString(), @"\s*«\s*(?<msg>.*)\s*»\s*", m => $"__critical(\"{m.Get("msg").Trim()}\")");
        }
#pragma warning restore RCS1197
    }
}
